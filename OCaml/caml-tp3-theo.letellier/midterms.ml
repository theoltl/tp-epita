#use "list_tools.ml";;(*==============================================================================================================*)(*Exercice 1 : Immédiatement décodable*)(*is_prefix*)let rec is_prefix l ll = match ll with  |[] -> false  |e::q when prefix (e,l) -> true  |e::q -> is_prefix l q;;(*--------------------------------------------------------------------------------------------------------*)(*Decodable*)let rec decodable l = match l with  |[]-> true  |e::q when is_prefix e q -> false  |e::q -> true;;(*==============================================================================================================*)(*Exercice 2 : Stock*)(*Refill*)let rec refill (nb,obj) ll =   if nb < 0 then invalid_arg "nb doit etre positif"   else     match ll with      [] -> append ll [(nb,obj)]    |(x,y)::l when y = obj -> ((x+nb),obj)::l    |e::l -> e::refill(nb,obj) l;;(*--------------------------------------------------------------------------------------------------------*)(*Destock*)let rec destock (nb,obj) ll =  if nb < 0 then invalid_arg "nb doit etre positif"  else    match ll with      [] -> (ll,nb)    |(x,y)::l when y = obj && (x-nb) <= 0 -> (l, (nb-x))    |(x,y)::l when y = obj && (x-nb) > 0 -> ((((x-nb),obj)::l),0)      |e::l -> let (x,y) = (destock (nb,obj)l) in (append [e] x,y);;(*--------------------------------------------------------------------------------------------------------*)(*Tentative shopping mais échec*)let rec shopping shopList stock =  match (shopList, stock) with    |(((nb,obj)::l),(x,y)::q) when y = obj && (x-nb) < 0 -> (stock,[((nb-x),obj)])    |(((nb,obj)::l),(x,y)::q) when y = obj && (x-nb) = 0 -> (q,([]))    |(((nb,obj)::l),(x,y)::q) when y = obj && (x-nb) > 0 -> ((((x-nb),obj)::l),([]))    |((nb,obj)::l,(x,y)::q) -> let (x,y) = (shopping shopList q) in (append [(nb,obj)]x,y)    |([],_)-> (stock,[])    |(_,[])-> (shopList,[]);;(*==============================================================================================================*)(*Exercice 3 : Rivières numériques*)(*River*)let rec river n rank =  if n < 0 || rank < 0 then invalid_arg "n and rank must be positive"  else    if rank = 0 then []    else n::(river (n+sum_digits(n)) (rank-1));;	  	(*--------------------------------------------------------------------------------------------------------*)(*Meeting*)let meeting n rank =  if common ((river 1 rank),(river n rank))> 0 then    (1,common((river 1 rank),river n rank))  else    if common ((river 3 rank),(river n rank))> 0 then      (3,common((river 3 rank),river n rank))    else     if common ((river 9 rank),(river n rank))> 0 then       (9,common((river 9 rank),river n rank))     else       (0,0);;